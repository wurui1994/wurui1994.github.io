<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OSX与iOS内核编程 笔记 | WuRui</title><meta name="author" content="WuRui"><meta name="copyright" content="WuRui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OS.X and iOS Kernel Programming.mdhttps:&#x2F;&#x2F;github.com&#x2F;Apress&#x2F;os-x-ios-kernel-programminghttps:&#x2F;&#x2F;github.com&#x2F;knightsc&#x2F;osx_and_ios_kernel_programming Memory Allocation in Machkmem_alloc&#x2F;kmem_alloc_co">
<meta property="og:type" content="article">
<meta property="og:title" content="OSX与iOS内核编程 笔记">
<meta property="og:url" content="https://wurui1994.github.io/2023/06/27/osx-and-ios-kernel/index.html">
<meta property="og:site_name" content="WuRui">
<meta property="og:description" content="OS.X and iOS Kernel Programming.mdhttps:&#x2F;&#x2F;github.com&#x2F;Apress&#x2F;os-x-ios-kernel-programminghttps:&#x2F;&#x2F;github.com&#x2F;knightsc&#x2F;osx_and_ios_kernel_programming Memory Allocation in Machkmem_alloc&#x2F;kmem_alloc_co">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wurui1994.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-06-27T06:10:16.000Z">
<meta property="article:modified_time" content="2023-08-20T01:18:43.708Z">
<meta property="article:author" content="WuRui">
<meta property="article:tag" content="book">
<meta property="article:tag" content="macos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wurui1994.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wurui1994.github.io/2023/06/27/osx-and-ios-kernel/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.bootcdn.net/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.bootcdn.net/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OSX与iOS内核编程 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-20 09:18:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">90</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="WuRui"><span class="site-name">WuRui</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">OSX与iOS内核编程 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-27T06:10:16.000Z" title="发表于 2023-06-27 14:10:16">2023-06-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-20T01:18:43.708Z" title="更新于 2023-08-20 09:18:43">2023-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/macos/">macos</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div><article class="post-content" id="article-container"><p>OS.X and iOS Kernel Programming.md<br><a target="_blank" rel="noopener" href="https://github.com/Apress/os-x-ios-kernel-programming">https://github.com/Apress/os-x-ios-kernel-programming</a><br><a target="_blank" rel="noopener" href="https://github.com/knightsc/osx_and_ios_kernel_programming">https://github.com/knightsc/osx_and_ios_kernel_programming</a></p>
<h2 id="Memory-Allocation-in-Mach"><a href="#Memory-Allocation-in-Mach" class="headerlink" title="Memory Allocation in Mach"></a>Memory Allocation in Mach</h2><p>kmem_alloc&#x2F;kmem_alloc_contig&#x2F;kmem_free</p>
<p>The I&#x2F;O Kit framework consists of the kernel level framework, as well as a user space framework called IOKit.framework.<br>The kernel framework is written in Embedded C++, a subset of C++, whereas the user space framework is C-based.</p>
<p>In the case of a USB-based storage device, it might depent on the IOUSBFamily, as well as<br>the IOStorageFamily.</p>
<p>In addition to standard C++ runtime, libkern also provides a number of useful classes, the<br>most fundamental being OSObject, the superclass of every class in I&#x2F;O kit.</p>
<p>The platform expert itself will form the root node of the tree, IOPlatformExpertDevice.</p>
<h1 id="chapter-3"><a href="#chapter-3" class="headerlink" title="chapter 3"></a>chapter 3</h1><p>Xcode and the Kernel Development Environment<br>The features that are not available include the following:<br>Exceptions&#x2F;Multiple inheritance&#x2F;Templates&#x2F;Runtime type information</p>
<ul>
<li>Although both templates create a kernel extension, an I&#x2F;O Kit driver reuires us to nominate<br>a hardware device it will match against and will load only if that device is present.<br>A generic kernel extension, on the other hand, is not a hardware driver and can be loaded<br>any time by the user</li>
<li>Rather than a compile-time linking, the kernel resolves any library dependencies of a kernel<br>extension only when the kernel extension is loaded.</li>
<li>Version 9.0.0 corresponds to Mac OS X 10.5.0, the version of the Mac OS X kernel.[uname -r]</li>
</ul>
<h1 id="chapter-4"><a href="#chapter-4" class="headerlink" title="chapter 4"></a>chapter 4</h1><p>The I&#x2F;O Kit Framework<br>Kernel.framework&#x2F;IOKit.framework</p>
<ul>
<li>The kernel will refuse to load an extension that contains symbols that collide with an<br>extension that is already loaded, and so to avoid this, Apple recommends that all global<br>functions, classes, and variables are decorated with a reverse-DNS namming scheme.</li>
<li>Thankfully, the I&#x2F;O Kit provides a special nub known as IOResources that can be used as<br>the provider class of a driver that has no hardware device, such as the tutorial driver lised<br>here. In a system, there will be multiple drivers matching against the IOResources nub, and<br>so to allow more than one driver to attach itself to IOResources, the IOMatchCategory key in<br>the drivers’s matching dictionary must be defined.</li>
<li>Unlike the Windows Registry, the I&#x2F;O Registry is never written to disk or saved between<br>reboots of the computer.</li>
<li>include the macro OSDeclareDefaultDestructors()</li>
<li>OSSymbol(which is a subclass of OSString). When a new instance of OSSymbol is created, the constructor checks for an existing OSSymbol object that contains the same string value, and if<br>one is found, returns an instance of the existing object rather than creating a new instance.</li>
<li>All libkern container classes can be iterated over using the class OSCollectionIterator.</li>
</ul>
<h1 id="chapter-5"><a href="#chapter-5" class="headerlink" title="chapter 5"></a>chapter 5</h1><p>Interacting with Drivers from Applications</p>
<ul>
<li>In the kernel, a driver that provides a serial port will create an instance of the standard<br>I&#x2F;O Kit class IOSerialStreamSync. The I&#x2F;O Kit’s serial family will create a device node in<br>the &#x2F;dev directory, publishing the path of the node in the I&#x2F;O Registry so that applications<br>can find it.[#define super IOSerialDriverSync] -&gt; IOSerialBSDClient</li>
<li>IOServiceMatching&#x2F;IOServiceGetMatchingServices&#x2F;IOIteratorNext<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">notificationPort = <span class="built_in">IONotificationPortCreate</span>(kIOMasterPortDefault);</span><br><span class="line">runLoopSource = <span class="built_in">IONotificationPortGetRunLoopSource</span>(notificationPort);</span><br><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">kr = <span class="built_in">IOServiceAddMatchingNotification</span>(notificationPort, kIOFirstMatchNotification, matchingDict, DeviceAdded, <span class="literal">NULL</span>, &amp;iter);</span><br><span class="line"><span class="built_in">DeviceAdded</span>(<span class="literal">NULL</span>, iter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRun</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">IONotificationPortDestroy</span>(notificationPort);</span><br></pre></td></tr></table></figure></li>
<li>IOServiceAddInterestNotification<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kIOGeneralInterest</span></span><br><span class="line"><span class="keyword">if</span> (messageType == kIOMessageServiceIsTerminated)</span><br></pre></td></tr></table></figure></li>
<li>Modifying Driver Properties</li>
<li>State-Based Interaction<br>To establish a connection to a driver, an application simply has to call the function IOServiceOpen(). -&gt; IOUserClient<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">custom_IOUserClient_class::start</span><span class="params">(IOService *provider)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FlockFlockClient::start client start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (! super::<span class="built_in">start</span>(provider))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    m_driver = <span class="built_in">OSDynamicCast</span>(custome_IOService_class_ptr, provider);</span><br><span class="line">    <span class="keyword">if</span> (!m_driver)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
IOConnectCallScalarMethod<br>IOConnectCallStructMethod<br>IOConnectCallMethod</li>
<li>Unlike the Windows driver model, which, unless explicitly enabled, does not allow an<br>application to send multiple control requests to a driver simultaneously, the I&#x2F;O Kit<br>allows as many threads to send requests to a user client as the application requires.</li>
<li>Allocating a Port on Which an Application Can Receive Notifications When an Asynchronous<br>Operation Completes</li>
<li>The I&#x2F;O Kit framework provides asynchronous variations of each of the IOConnectCallXXX()<br>functions named IOConnectCallAsyncXXX(). The asynchronoues form of these functions take<br>additional arguments, including a notification port, a callback function, and a context<br>parameter that is passed to the callback function.<br>IOConnectCallAsyncScalarMethod -&gt; sendAsyncResult64</li>
<li>To prevent the user client object from being released while the operation is in progress,<br>the method increments its retain count when starting the operation and decrements its retain<br>count when the operatin completes. Finally, when the background operation hash completed, the<br>user client (or driver) signals the user application by calling sendAsyncResult64().<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IOReturn</span><br><span class="line">IOUserClient::_sendAsyncResult64 -&gt;</span><br><span class="line">mach_msg_send_from_kernel_with_options/mach_msg_send_from_kernel_proper</span><br><span class="line">-&gt; kernel_mach_msg_send</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="chapter-6"><a href="#chapter-6" class="headerlink" title="chapter 6"></a>chapter 6</h1><p>Memory Mangement</p>
<ul>
<li>In fact, if you use I&#x2F;O Kit, it will do all the required translations for you automatically<br>if you use IOMemoryDescriptor, which is discussed later in this chapter.</li>
<li>All current-generation Macs are litter-endian, as the Intel x86&#x2F;x86_64 processors are little-endiansl; so too are ARM-based iOS devices. The older PowerPC-based Macs were big-endian.<br>vm_page_grab&#x2F;vm_page_alloc</li>
<li>As a kernel programmer, you can create your own zones with the zinit() function if you have<br>a need for frequent and fast allocation and de-allocation of data objects of the same type. To create a new zonem you need to tell the allocator the size of the object, the maximum size of the queue, and the allocation size, which specifies how mush memory will be added when zone is exhausted.</li>
<li>The kalloc family provides a slightly higher-level interface for fast memory allocation.</li>
<li>The kalloc functions and variants, except kalloc_noblock(), may block (sleep) to obtain memory. The same is true for the kfree() function. Therefore, you must use kalloc_noblock() if you need memory in an interrupt context or while holding a simple lock.</li>
</ul>
<h2 id="I-x2F-O-Kit-Memory-Allocation"><a href="#I-x2F-O-Kit-Memory-Allocation" class="headerlink" title="I&#x2F;O Kit Memory Allocation"></a>I&#x2F;O Kit Memory Allocation</h2><p>IOMalloc&#x2F;IOMallocAligned&#x2F;IOMallocPageable<br>There is also a last variant, IOMallocContiguous(), that allocates memory that is physically contiguous. Its use is now deprecated. Apple recommends using IOBufferMemoryDescriptor instead.</p>
<h3 id="Mapping-Memory-from-a-User-Space-Task-into-Kernel-Space"><a href="#Mapping-Memory-from-a-User-Space-Task-into-Kernel-Space" class="headerlink" title="Mapping Memory from a User Space Task into Kernel Space"></a>Mapping Memory from a User Space Task into Kernel Space</h3><p>Note: It is not necessary to map memory into the kernel unless the kernel needs to actively modify it. If DMA is performed from a user space buffer and the data in the buffer does not have to be modified by the kernel, it is not necessary to map it into the kernel’s address space, the buffer can be transferred directly to a hardware device. See Chaptr 9 for more information about DMA.</p>
<h3 id="Mapping-Memory-form-the-Kernel-to-a-User-Space-Task"><a href="#Mapping-Memory-form-the-Kernel-to-a-User-Space-Task" class="headerlink" title="Mapping Memory form the Kernel to a User Space Task"></a>Mapping Memory form the Kernel to a User Space Task</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOConnectMapMemory -&gt; kIOMapAnyWhere</span><br></pre></td></tr></table></figure>
<h3 id="Mapping-Memory-to-a-Specific-User-Space-Task"><a href="#Mapping-Memory-to-a-Specific-User-Space-Task" class="headerlink" title="Mapping Memory to a Specific User Space Task"></a>Mapping Memory to a Specific User Space Task</h3><p>Apple recommends not mapping memory obtained from functions such as IOMalloc() and IOMallocAligned() (though it is possible using the latter) because they come from the zone allocator, which is intended for private and temporary allications and not for sharing. The recommended way of mapping memory is to use the IOBuferMemoryDescriptor, a subclass of IOMemoryDescriptor that also allocates memory.</p>
<h1 id="chapter-7"><a href="#chapter-7" class="headerlink" title="chapter 7"></a>chapter 7</h1><p>Synchronization and Threading</p>
<ul>
<li>Atomic Operations Provides By the Libkern Framework [libkern&#x2F;OSAtomic.h]<br>OS[Increment&#x2F;Decrement&#x2F;Add&#x2F;BitAnd&#x2F;BitOr&#x2F;BitXor]Atomic<br>OSCompareAndSwap&#x2F;OSTestAndSet&#x2F;OSTestAndClear</li>
<li>An Implementation of Object Reference Counting in a Multithreaded Environment<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Object::retain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">OSIncrementAtomic</span>(&amp;retainCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Object::release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">uint32_t</span> originalValue;</span><br><span class="line">	originalValue = <span class="built_in">OSDecrementAtomic</span>(&amp;retainCount);</span><br><span class="line">	<span class="keyword">if</span> (originalValue == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">free</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>The compare and swap function can be used to build more complex atomic operations.<br>Note: All atomic operations, such as OSAddAtomoc(), OSIncrementAtomic(), and OSBitOrAtomic() can be implemented using only OSCompareAndSwap(). In face, a number of atomic functions provided by the libkern library are implemented this way, including all bitwise atomic operations and the 8-bit and 16-bit variations of each operation, which perform a compare and swap on the full 32-bit word containing the value being modified.</li>
<li>Locking<br>IOSimpleLock -&gt; spin lock<br>IOLock -&gt; traditional mutex<br>IORecursiveLock<br>IORWLock</li>
<li>Unlike a mutex, an IOSimpleLock will never suspend the running thread. Instead it will spin until the lock becomes available. This makes IOSimpleLock perfect for providing synchronization between code that runs within a primiary interrupt handler and non-interrupt code. In reality, this functionality is rarely needed within an I&#x2F;O Kit driver since most drivers won’t ever have to hanlde an interrupt directly and, if they do, most will defer the interrupt to a secondary intterupt handler. The I&#x2F;O Kit provides other locking mechanisms that are appropriate for secondary interrupt handles, which are discussed later in this chapter.</li>
<li>Mutex. Because a mutex may block if it cannot be acquired immediately, mutex locks cannot be used within an interrupt handler.</li>
<li>Condition Variables<br>IOLockSleep&#x2F;IOLockWakeup<br>The behavior of IOLockSleep() is similar to that of its equivalent user space function pthread_cond_wait.</li>
<li>Condition variables in the I&#x2F;O Kit do not have a specific type, rather a condiation variable is an arbitary void* that uniquely identifies an event. A driver will usually use the address of an instance variable (such as the address of the lock itself) as a condition varibale, since the use of an address guarantees that the value will be unique among multiple instances of the driver and other drivers in the system.</li>
<li>Read&#x2F;Write Mutexes<br>The I&#x2F;O Kit provides read&#x2F;write mutexes through an object known as IORWLock.</li>
<li>GetMachLock<br>IOSimpleLockGetMachLock -&gt; lck_spin_t<br>IOLockGetMachLock -&gt; lck_mtx_t<br>IORecursiveLockGetMachLock -&gt; lck_mtx_t<br>IORWLockGetMachLock -&gt; lck_rw_t<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">_pthread_mutex_fairshare_lock_wait -&gt;</span><br><span class="line">__psynch_mutexwait -&gt; ksyn_wait</span><br><span class="line">-&gt; pthread_kern-&gt;psynch_wait_update_complete</span><br><span class="line">-&gt; turnstile_update_inheritor_complete</span><br><span class="line"><span class="comment">// ksyn_wait type</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">thread_snapshot_wait_flags</span> &#123;</span><br><span class="line">	kThreadWaitNone                 = <span class="number">0x00</span>,</span><br><span class="line">	kThreadWaitKernelMutex          = <span class="number">0x01</span>,</span><br><span class="line">	kThreadWaitPortReceive          = <span class="number">0x02</span>,</span><br><span class="line">	kThreadWaitPortSetReceive       = <span class="number">0x03</span>,</span><br><span class="line">	kThreadWaitPortSend             = <span class="number">0x04</span>,</span><br><span class="line">	kThreadWaitPortSendInTransit    = <span class="number">0x05</span>,</span><br><span class="line">	kThreadWaitSemaphore            = <span class="number">0x06</span>,</span><br><span class="line">	kThreadWaitKernelRWLockRead     = <span class="number">0x07</span>,</span><br><span class="line">	kThreadWaitKernelRWLockWrite    = <span class="number">0x08</span>,</span><br><span class="line">	kThreadWaitKernelRWLockUpgrade  = <span class="number">0x09</span>,</span><br><span class="line">	kThreadWaitUserLock             = <span class="number">0x0a</span>,</span><br><span class="line">	kThreadWaitPThreadMutex         = <span class="number">0x0b</span>,</span><br><span class="line">	kThreadWaitPThreadRWLockRead    = <span class="number">0x0c</span>,</span><br><span class="line">	kThreadWaitPThreadRWLockWrite   = <span class="number">0x0d</span>,</span><br><span class="line">	kThreadWaitPThreadCondVar       = <span class="number">0x0e</span>,</span><br><span class="line">	kThreadWaitParkedWorkQueue      = <span class="number">0x0f</span>,</span><br><span class="line">	kThreadWaitWorkloopSyncWait     = <span class="number">0x10</span>,</span><br><span class="line">	kThreadWaitOnProcess            = <span class="number">0x11</span>,</span><br><span class="line">	kThreadWaitSleepWithInheritor   = <span class="number">0x12</span>,</span><br><span class="line">	kThreadWaitEventlink            = <span class="number">0x13</span>,</span><br><span class="line">	kThreadWaitCompressor           = <span class="number">0x14</span>,</span><br><span class="line">&#125; __attribute__((packed)) <span class="type">block_hint_t</span>;</span><br><span class="line"><span class="comment">// pthread_workqueue.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">event_t</span></span></span><br><span class="line"><span class="function"><span class="title">workq_parked_wait_event</span><span class="params">(<span class="keyword">struct</span> uthread *uth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">event_t</span>)&amp;uth-&gt;uu_workq_stackaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">workq_thread_wakeup</span><span class="params">(<span class="keyword">struct</span> uthread *uth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">thread_wakeup_thread</span>(<span class="built_in">workq_parked_wait_event</span>(uth), <span class="built_in">get_machthread</span>(uth));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_wait -&gt; assert_wait -&gt; thread_block</span><br><span class="line">lck_mtx_sleep -&gt; assert_wait/thread_block</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Synchronizing-Asynchronous-Events-Work-Loops"><a href="#Synchronizing-Asynchronous-Events-Work-Loops" class="headerlink" title="Synchronizing Asynchronous Events: Work Loops"></a>Synchronizing Asynchronous Events: Work Loops</h2><p>To simplify the work required by the driver developer, the I&#x2F;O Kit provides a class known as IOWorkLoop that creates a single thread on which all asynchronous evetns are handle. In I&#x2F;O Kit nomenclature, this thread is known as a “work loop” and a driver reigster any of its asynchronous event sources, such as interrupt hanlders and timers, with an IOWorkLoop object.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IOTimerEventSource::timerEventSource</span><br><span class="line">QEventLoop::exec -&gt; QEventLoop::processEvents</span><br><span class="line">QEventLoop::WaitForMoreEvents</span><br><span class="line">mac -&gt; CFRunLoopRunInMode/<span class="built_in">IOWorkLoop</span>(driver)</span><br><span class="line">win -&gt; MsgWaitForMultipleObjectsEx</span><br><span class="line">unix -&gt; qt_safe_poll [d-&gt;pollfds.<span class="built_in">append</span>(d-&gt;threadPipe.<span class="built_in">prepare</span>());]</span><br><span class="line">glib -&gt; g_main_context_iteration</span><br></pre></td></tr></table></figure>
<p>An driver will typically specify a static method in its main driver class as the callback function of an IOEventSource.</p>
<ul>
<li>IOCommandGate<br>A command gate is installed on a work loop like any other event source but, instead of generating events itself, it is used to execute an arbitrary callback function on the work loop thread. [runAction()]<br>The IOCommandGate achieves its synchronization throught a recursive lock. This allows a function that has been called throught the IOCommanGate to call other functions through the same IOCommandGate without causing a deadlock.</li>
<li>Timers<br>IOTimerEventSource</li>
<li>Releasing Work Loops<br>The first part is usually performed by a driver in its stop() method, but the work loop itself is typically not released until the driver’s free() method is called.</li>
</ul>
<h2 id="Kernel-Threads"><a href="#Kernel-Threads" class="headerlink" title="Kernel Threads"></a>Kernel Threads</h2><p>In these cases, a driver can create its own kernel thread on which to continue executing code without tying up the thread of a user process or the work loop thread.<br>kernel_thread_start&#x2F;thread_deallocate&#x2F;thread_terminate<br>Note that althought it might seem that it is possible to termiate a background thread from another thread, this will fail with an error returned to the caller. The thread_termiate() function only allows the current thread to ber terminated.</p>
<h1 id="chapter-8"><a href="#chapter-8" class="headerlink" title="chapter 8"></a>chapter 8</h1><p>Universal Serial Bus<br>It is worth mentioning that USE drivers can bewritten both in the kernel and in user space.</p>
<h2 id="I-x2F-O-Kit-USB-Support"><a href="#I-x2F-O-Kit-USB-Support" class="headerlink" title="I&#x2F;O Kit USB Support"></a>I&#x2F;O Kit USB Support</h2><p>IOUSEFamily -&gt; com.apple.iokit.IOUSBFamily</p>
<h1 id="chapter-9"><a href="#chapter-9" class="headerlink" title="chapter 9"></a>chapter 9</h1><p>PCI Express and Thunderbolt<br>IOPCIFamily</p>
<h2 id="I-x2F-O-Kit-Interrupt-Mechanisms"><a href="#I-x2F-O-Kit-Interrupt-Mechanisms" class="headerlink" title="I&#x2F;O Kit Interrupt Mechanisms"></a>I&#x2F;O Kit Interrupt Mechanisms</h2><p>IOFilterInterruptEventSource&#x2F;IOInterruptEventSource</p>
<h3 id="Direct-Memory-Access"><a href="#Direct-Memory-Access" class="headerlink" title="Direct Memory Access"></a>Direct Memory Access</h3><h1 id="chapter-10"><a href="#chapter-10" class="headerlink" title="chapter 10"></a>chapter 10</h1><p>Power Management<br>IOPMPowerState</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake any threads that are blocked on a power state change</span></span><br><span class="line"><span class="built_in">IOLockWakeup</span>(m_lock, &amp;m_devicePowerState, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h1 id="chapter-11"><a href="#chapter-11" class="headerlink" title="chapter 11"></a>chapter 11</h1><p>Serial Port Drivers<br>It is very flexible interface. The serial driver is concrened only with transferring date bytes between the serial port and the user space application.</p>
<ul>
<li>Devices that use serial ports include GPS receivers and barcode scanners. They are also commonly used to provide debugging output on hardware.<br>IOSerialFamily</li>
</ul>
<h1 id="chapter-12"><a href="#chapter-12" class="headerlink" title="chapter 12"></a>chapter 12</h1><p>Audio Driver</p>
<h1 id="chapter-13"><a href="#chapter-13" class="headerlink" title="chapter 13"></a>chapter 13</h1><p>Networking</p>
<ul>
<li>Another feature of the XNU kernel is the network kernel extensions (NKE) mechanism. NKE allows filtrs to be inserted at various levels of the network stack, such as in sockets layer or IP layer. The NKE architecture allows you to write custom routing algorithms, and implment new protocols and virtual network interfaces. It can also be used for packet filtering and logging. Furthermore, the kernel supports the Berkeley Packet Filter (BPF), which allows raw network traffice to be routed to user space for analysis with tools such as tcpdump.</li>
</ul>
<h2 id="Network-Memory-Buffers"><a href="#Network-Memory-Buffers" class="headerlink" title="Network Memory Buffers"></a>Network Memory Buffers</h2><p>Network Memory Buffers, or mbufs, is a fundamental data structure in BSD UNIX systems, including Mac OS X and iOS.<br>mbuf_copydata&#x2F;mbuf_copyback</p>
<h2 id="Network-Kernel-Extensions"><a href="#Network-Kernel-Extensions" class="headerlink" title="Network Kernel Extensions"></a>Network Kernel Extensions</h2><p>pcap -&gt; bpf -&gt; nke&#x2F;ke</p>
<h1 id="chapter-14"><a href="#chapter-14" class="headerlink" title="chapter 14"></a>chapter 14</h1><p>Storge Systems<br>IOBlockStorageDevice</p>
<h1 id="chapter-15"><a href="#chapter-15" class="headerlink" title="chapter 15"></a>chapter 15</h1><p>User-Space USB Drivers<br>Not all hardware devices can be controlled through a user-sapce dirver; for example, devices that contains a memory-mapped address range require a kernel driver. Similarly, devices that generate interrupts need a kernel driver, since only kernel code can execute at primary interrupt level. This means that all PCI and Thunderbolt devices need to be supported by a kernel driver. However, USB- and FireWire- based hardware devices are perfect candidates for a user-space driver.</p>
<ul>
<li>An application doesn’t need to call the methods from the user client class directly; instead, the I&#x2F;O Kit framework provides a high level API to control the hardware. This API is known as IOUSELib.<br>IOCreatePlugInInterfaceForService<br>Note: If you are familiar with Microsoft’s Component Object Model (COM), you will instantly recognize the method name QueryInterface(). All IOUSBLib classes are based on the COM programming model and are derived from the base class IUnknown. The biggest impact of this design on an application using IOUSBLib is that all IOUSBLib objects are references counted; they can be retained by calling the method AddRef() and can be release by calling the method Release().</li>
</ul>
<h1 id="chapter-16"><a href="#chapter-16" class="headerlink" title="chapter 16"></a>chapter 16</h1><p>Debugging</p>
<h2 id="Common-Types-of-Problems"><a href="#Common-Types-of-Problems" class="headerlink" title="Common Types of Problems"></a>Common Types of Problems</h2><ul>
<li>Race Conditions</li>
<li>Deadlocks</li>
<li>Lock Contention</li>
<li>Access to Invalid Memory</li>
<li>Memroy and Resources Leaks</li>
<li>Illegal Instruction&#x2F;Operand</li>
<li>Blocking in Primary Interrupt Context</li>
<li>Volunteered Panics</li>
</ul>
<h3 id="Printing-Stack-Traces"><a href="#Printing-Stack-Traces" class="headerlink" title="Printing Stack Traces"></a>Printing Stack Traces</h3><p>IOLog&#x2F;OSReportWithBackTrace()</p>
<h1 id="chapter-17"><a href="#chapter-17" class="headerlink" title="chapter 17"></a>chapter 17</h1><p>Advanced Kernel Programming<br>IOServiceOpen&#x2F;CFMachPortCreate&#x2F;IOConnectSetNotificationPort&#x2F;mach_msg_send_from_kernel</p>
<h1 id="chapter-18"><a href="#chapter-18" class="headerlink" title="chapter 18"></a>chapter 18</h1><p>Deployment</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wurui1994.github.io">WuRui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wurui1994.github.io/2023/06/27/osx-and-ios-kernel/">https://wurui1994.github.io/2023/06/27/osx-and-ios-kernel/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wurui1994.github.io" target="_blank">WuRui</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/book/">book</a><a class="post-meta__tags" href="/tags/macos/">macos</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/27/macos-ios-internals-vol-one/" title="深入解析MacOS和iOS 卷一 笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深入解析MacOS和iOS 卷一 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/27/macos-cmds/" title="macOS命令行"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">macOS命令行</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/25/algo-book/" title="算法书籍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-25</div><div class="title">算法书籍</div></div></a></div><div><a href="/2023/06/27/book-note/" title="书籍记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-27</div><div class="title">书籍记录</div></div></a></div><div><a href="/2023/06/27/macos-cmds/" title="macOS命令行"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-27</div><div class="title">macOS命令行</div></div></a></div><div><a href="/2023/06/26/macos-image/" title="macOS镜像"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="title">macOS镜像</div></div></a></div><div><a href="/2023/06/27/macos-ios-internals-vol-one/" title="深入解析MacOS和iOS 卷一 笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-27</div><div class="title">深入解析MacOS和iOS 卷一 笔记</div></div></a></div><div><a href="/2023/06/27/macos-ios-internals-vol-three/" title="深入解析MacOS和iOS 卷三 笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-27</div><div class="title">深入解析MacOS和iOS 卷三 笔记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">WuRui</div><div class="author-info__description">每天都是新的一天</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">90</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wurui1994" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/wechat.jpg" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="mailto:1341531859@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn"></i><span>公告</span></div><div class="announcement_content">这里是我的博客, <a href=https://www.cnblogs.com/wurui1994/>旧博客地址</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Allocation-in-Mach"><span class="toc-number">1.</span> <span class="toc-text">Memory Allocation in Mach</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-3"><span class="toc-number"></span> <span class="toc-text">chapter 3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-4"><span class="toc-number"></span> <span class="toc-text">chapter 4</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-5"><span class="toc-number"></span> <span class="toc-text">chapter 5</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-6"><span class="toc-number"></span> <span class="toc-text">chapter 6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O-Kit-Memory-Allocation"><span class="toc-number">1.</span> <span class="toc-text">I&#x2F;O Kit Memory Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-Memory-from-a-User-Space-Task-into-Kernel-Space"><span class="toc-number">1.1.</span> <span class="toc-text">Mapping Memory from a User Space Task into Kernel Space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-Memory-form-the-Kernel-to-a-User-Space-Task"><span class="toc-number">1.2.</span> <span class="toc-text">Mapping Memory form the Kernel to a User Space Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mapping-Memory-to-a-Specific-User-Space-Task"><span class="toc-number">1.3.</span> <span class="toc-text">Mapping Memory to a Specific User Space Task</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-7"><span class="toc-number"></span> <span class="toc-text">chapter 7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronizing-Asynchronous-Events-Work-Loops"><span class="toc-number">1.</span> <span class="toc-text">Synchronizing Asynchronous Events: Work Loops</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kernel-Threads"><span class="toc-number">2.</span> <span class="toc-text">Kernel Threads</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-8"><span class="toc-number"></span> <span class="toc-text">chapter 8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O-Kit-USB-Support"><span class="toc-number">1.</span> <span class="toc-text">I&#x2F;O Kit USB Support</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-9"><span class="toc-number"></span> <span class="toc-text">chapter 9</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O-Kit-Interrupt-Mechanisms"><span class="toc-number">1.</span> <span class="toc-text">I&#x2F;O Kit Interrupt Mechanisms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Direct-Memory-Access"><span class="toc-number">1.1.</span> <span class="toc-text">Direct Memory Access</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-10"><span class="toc-number"></span> <span class="toc-text">chapter 10</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-11"><span class="toc-number"></span> <span class="toc-text">chapter 11</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-12"><span class="toc-number"></span> <span class="toc-text">chapter 12</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-13"><span class="toc-number"></span> <span class="toc-text">chapter 13</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Network-Memory-Buffers"><span class="toc-number">1.</span> <span class="toc-text">Network Memory Buffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Network-Kernel-Extensions"><span class="toc-number">2.</span> <span class="toc-text">Network Kernel Extensions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-14"><span class="toc-number"></span> <span class="toc-text">chapter 14</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-15"><span class="toc-number"></span> <span class="toc-text">chapter 15</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-16"><span class="toc-number"></span> <span class="toc-text">chapter 16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Common-Types-of-Problems"><span class="toc-number">1.</span> <span class="toc-text">Common Types of Problems</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Printing-Stack-Traces"><span class="toc-number">1.1.</span> <span class="toc-text">Printing Stack Traces</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-17"><span class="toc-number"></span> <span class="toc-text">chapter 17</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-18"><span class="toc-number"></span> <span class="toc-text">chapter 18</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/02/media-guide/" title="学习入门">学习入门</a><time datetime="2024-03-02T01:00:12.000Z" title="发表于 2024-03-02 09:00:12">2024-03-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/22/clipboard-note/" title="clipboard笔记">clipboard笔记</a><time datetime="2023-10-22T08:54:25.000Z" title="发表于 2023-10-22 16:54:25">2023-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/04/optimize-note/" title="优化相关">优化相关</a><time datetime="2023-08-04T06:51:45.000Z" title="发表于 2023-08-04 14:51:45">2023-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/04/love-note/" title="关于爱情">关于爱情</a><time datetime="2023-08-04T00:35:24.000Z" title="发表于 2023-08-04 08:35:24">2023-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/dopamine-note/" title="多巴胺相关">多巴胺相关</a><time datetime="2023-07-20T06:47:32.000Z" title="发表于 2023-07-20 14:47:32">2023-07-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By WuRui</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function getGiscusTheme (theme) {
  return theme === 'dark' ? 'dark' : 'light'
}

function loadGiscus () {
  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'wurui1994/wurui1994.github.io',
    'data-repo-id': 'R_kgDOJzB0HA',
    'data-category-id': 'DIC_kwDOJzB0HM4CXeHj',
    'data-lang': 'zh-CN',
    'data-mapping': 'pathname',
    'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme (theme) {
  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame')
    if (!iframe) return
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
  }

  sendMessage({
    setConfig: {
      theme: getGiscusTheme(theme)
    }
  });
}

btf.addModeChange('giscus', changeGiscusTheme)

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/butterfly-extsrc/1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>